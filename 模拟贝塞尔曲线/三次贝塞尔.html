<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<canvas width="400" height="400" id="canvas"></canvas>
</body>
</html>
<script>
  const ctx = document.getElementById('canvas')
  const c = ctx.getContext('2d')

  // 利用二元一次方程式求解 y = ax
  // 起点 start: 200 = 20 * x
  // 控制点 cOne: 20 = 100 * x
  const start = [20, 380]
  const cOne = [50, 50]
  const cTwo = [350, 50]
  const end = [380, 380]

  // 求出起始点的变化函数
  const speedS = getRate(start, cOne)

  function draw(fList) {
    fList.forEach(item => {
      c.beginPath()
      c.fillStyle = 'green'
      c.arc(item[0], item[1], 2, 0, Math.PI * 2)
      c.fill()
    })

    // 起点和终点
    c.fillStyle = 'blue';
    c.beginPath();
    c.arc(start[0], start[1], 5, 0, 2 * Math.PI);   // Start point
    c.arc(end[0], end[1], 5, 0, 2 * Math.PI);  // End point
    c.fill();

    // 控制点
    c.fillStyle = 'red';
    c.beginPath();
    c.arc(cOne[0], cOne[1], 5, 0, 2 * Math.PI);
    c.arc(cTwo[0], cTwo[1], 5, 0, 2 * Math.PI);
    c.fill();

    // 链接各个点
    c.save()
    c.setLineDash([5, 5])
    c.strokeStyle = 'green'

    c.beginPath();
    c.moveTo(start[0], start[1]);
    c.lineTo(cOne[0], cOne[1]);
    c.stroke();

    c.beginPath();
    c.moveTo(cOne[0], cOne[1]);
    c.lineTo(cTwo[0], cTwo[1]);
    c.stroke();

    c.beginPath();
    c.moveTo(cTwo[0], cTwo[1]);
    c.lineTo(end[0], end[1]);
    c.stroke();

    c.restore()
  }

  const slong = getDis(start, cOne)

  let speed = 0.1;

  let subStart = [...start]

  const fList = []

  function sport() {
    c.clearRect(0, 0, ctx.width, ctx.height);
    subStart[0] = subStart[0] + speed
    subStart[1] = subStart[1] + speed * speedS

    // 起始点到控制点的运行比例
    const process = getDis(start, subStart)
    const ratio = process / slong
    // 运动的终止点位置
    const subEnd = getPoint(cTwo, end, ratio)

    const subTop = getPoint(cOne, cTwo, ratio)

    const subSt = getPoint(subStart, subTop, ratio)

    const subTe = getPoint(subTop, subEnd, ratio)

    const F = getPoint(subSt, subTe, ratio)

    fList.push(F)

    draw(fList)

    // F点的变化轨迹
    c.beginPath()
    c.fillStyle = 'red'
    c.arc(F[0], F[1], 5, 0, Math.PI * 2)
    c.fill()

    // 起点变化轨迹
    c.beginPath()
    c.fillStyle = 'orange'
    c.arc(subStart[0], subStart[1], 4, 0, Math.PI * 2)
    c.fill()

    // 两个控制点之间
    c.beginPath()
    c.fillStyle = 'orange'
    c.arc(subTop[0], subTop[1], 4, 0, Math.PI * 2)
    c.fill()

    // 终点变化轨迹
    c.beginPath()
    c.fillStyle = 'orange'
    c.arc(subEnd[0], subEnd[1], 4, 0, Math.PI * 2)
    c.fill()

    // 起点 - 控制点1 变化辅助线
    c.save()
    c.setLineDash([3, 3])

    c.beginPath();
    c.strokeStyle = 'orange'
    c.moveTo(subStart[0], subStart[1])
    c.lineTo(subTop[0], subTop[1])
    c.stroke()

    // 控制点2 - 终点
    c.beginPath();
    c.strokeStyle = 'orange'
    c.moveTo(subTop[0], subTop[1])
    c.lineTo(subEnd[0], subEnd[1])
    c.stroke()

    // 控制点1 - 控制点2
    c.beginPath();
    c.strokeStyle = 'red'
    c.moveTo(subSt[0], subSt[1])
    c.lineTo(subTe[0], subTe[1])
    c.stroke()
    c.restore()

    if (subStart[0] >= cOne[0]) {
      subStart = [...start]

      return;
    }
    requestAnimationFrame(sport)
  }

  sport()

  // 获取运动中点的位置
  function getPoint(one, two, ratio) {
    return [
      (two[0] - one[0]) * ratio + one[0],
      (two[1] - one[1]) * ratio + one[1]
    ]
  }

  // 获取距离
  function getDis(p1, p2) {
    const x = p2[0] - p1[0]
    const y = p2[1] - p1[1]
    return Math.sqrt(x * x + y * y)
  }

  // 变化方程 （一元一次）
  function getRate(a, b) {
    return (b[1] - a[1]) / (b[0] - a[0]);
  }
</script>

